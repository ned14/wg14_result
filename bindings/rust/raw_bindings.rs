/* automatically generated by rust-bindgen 0.72.1 */

#[doc = "! \\brief Type of a unique id of a domain"]
pub type status_code_domain_unique_id_type = ::std::os::raw::c_ulonglong;
#[doc = "! \\brief Type of a string ref of a domain"]
pub type status_code_domain_string_ref = status_code_domain_string_ref_s;
pub const status_code_domain_string_ref_thunk_op_status_code_domain_string_ref_thunk_op_copy:
    status_code_domain_string_ref_thunk_op = 0;
pub const status_code_domain_string_ref_thunk_op_status_code_domain_string_ref_thunk_op_move:
    status_code_domain_string_ref_thunk_op = 1;
pub const status_code_domain_string_ref_thunk_op_status_code_domain_string_ref_thunk_op_destruct:
    status_code_domain_string_ref_thunk_op = 2;
#[doc = "! \\brief Type of a string ref thunk op"]
pub type status_code_domain_string_ref_thunk_op = ::std::os::raw::c_uint;
#[doc = "! \\brief Type of the arguments to a string ref thunk function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_domain_string_ref_thunk_args_s {
    pub dest: *mut status_code_domain_string_ref,
    pub src: *mut status_code_domain_string_ref,
    pub op: status_code_domain_string_ref_thunk_op,
}
impl Default for status_code_domain_string_ref_thunk_args_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief Type of the arguments to a string ref thunk function"]
pub type status_code_domain_string_ref_thunk_args = status_code_domain_string_ref_thunk_args_s;
#[doc = "! \\brief Type of a string ref thunk function. Returns an `errno` value.\n! Copies can fail. Nothing else can."]
pub type status_code_domain_string_ref_thunk_spec = ::std::option::Option<
    unsafe extern "C" fn(
        args: *const status_code_domain_string_ref_thunk_args,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "! \\brief Type of a string ref of a domain"]
#[repr(C)]
#[derive(Debug)]
pub struct status_code_domain_string_ref_s {
    pub c_str: *const ::std::os::raw::c_char,
    pub end: *const ::std::os::raw::c_char,
    pub state: [*mut ::std::os::raw::c_void; 3usize],
    pub thunk: status_code_domain_string_ref_thunk_spec,
}
impl Default for status_code_domain_string_ref_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "! \\brief An empty `status_code_domain_string_ref`"]
    pub static status_code_domain_string_ref_empty: status_code_domain_string_ref;
}
unsafe extern "C" {
    #[doc = "! \\brief Returns true if the string ref is empty"]
    pub fn status_code_domain_string_ref_is_empty(s: *const status_code_domain_string_ref) -> bool;
}
unsafe extern "C" {
    #[doc = "! \\brief Destroy a string ref"]
    pub fn status_code_domain_string_ref_destroy(_src: *const status_code_domain_string_ref);
}
unsafe extern "C" {
    #[doc = "! \\brief Attempt to copy a string ref, returning an `errno` cause if it\n! failed."]
    pub fn status_code_domain_string_ref_copy(
        dest: *mut status_code_domain_string_ref,
        src: *const status_code_domain_string_ref,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "! \\brief Attempt to move a string ref"]
    pub fn status_code_domain_string_ref_move(
        dest: *mut status_code_domain_string_ref,
        src: *mut status_code_domain_string_ref,
    );
}
unsafe extern "C" {
    #[doc = "! \\brief Make a string ref which refers to a null terminated static string\n! slice"]
    pub fn status_code_domain_string_ref_from_static_string_slice(
        s: *const ::std::os::raw::c_char,
        len: usize,
    ) -> status_code_domain_string_ref;
}
unsafe extern "C" {
    #[doc = "! \\brief Make a string ref which refers to a null terminated static string"]
    pub fn status_code_domain_string_ref_from_static_string(
        s: *const ::std::os::raw::c_char,
    ) -> status_code_domain_string_ref;
}
unsafe extern "C" {
    #[doc = "! \\brief Make an atomic refcounted string ref which tracks living copies\n! using an atomic reference count, freeing the internally stored buffer on\n! final destroy. The input range is copied and does not need to be null\n! terminated. Failure to malloc causes a static string ref to be returned\n! with a string like \"failed to get message from system\"."]
    pub fn status_code_domain_string_ref_atomic_refcounted_from_buffer(
        s: *const ::std::os::raw::c_char,
        len: usize,
    ) -> status_code_domain_string_ref;
}
unsafe extern "C" {
    #[doc = "! \\brief Make an atomic refcounted string ref which copies the input null\n! terminated static string"]
    pub fn status_code_domain_string_ref_atomic_refcounted_from_string(
        s: *const ::std::os::raw::c_char,
    ) -> status_code_domain_string_ref;
}
#[doc = "! \\brief The functions defined by a status code domain, kept ABI compatible\n! with a C++ vtable"]
pub type status_code_domain = status_code_domain_s;
#[doc = "! \\brief Type of a payload info of a domain"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct status_code_domain_payload_info_t {
    #[doc = "!< The payload size in bytes"]
    pub payload_size: usize,
    #[doc = "!< The total status code size in bytes (includes domain pointer and mixins state)"]
    pub total_size: usize,
    #[doc = "!< The total status code alignment in bytes"]
    pub total_alignment: usize,
}
unsafe extern "C" {
    #[doc = "! \\brief Make a `status_code_domain_payload_info_t`"]
    pub fn status_code_domain_payload_info_make(
        payload_size: usize,
        total_size: usize,
        total_alignment: usize,
    ) -> status_code_domain_payload_info_t;
}
#[doc = "! \\brief Type of an untyped status code"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_untyped {
    pub domain: *const status_code_domain_s,
}
impl Default for status_code_untyped {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type status_code_generic = status_code_generic_s;
#[doc = "! \\brief The arguments for `status_code_domain_vtable.name`"]
#[repr(C)]
#[derive(Debug)]
pub struct status_code_domain_vtable_name_args {
    pub ret: status_code_domain_string_ref,
    pub domain: *const status_code_domain_s,
}
impl Default for status_code_domain_vtable_name_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The arguments for `status_code_domain_vtable.payload_info`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_domain_vtable_payload_info_args {
    pub ret: status_code_domain_payload_info_t,
    pub domain: *const status_code_domain_s,
}
impl Default for status_code_domain_vtable_payload_info_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The arguments for `status_code_domain_vtable.message`"]
#[repr(C)]
#[derive(Debug)]
pub struct status_code_domain_vtable_message_args {
    pub ret: status_code_domain_string_ref,
    pub code: *const status_code_untyped,
}
impl Default for status_code_domain_vtable_message_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The functions defined by a status code domain, kept ABI compatible\n! with a C++ vtable"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct status_code_domain_vtable_s {
    #[doc = "! Name of this category. Returns an `errno` if it failed."]
    pub name: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary0: *const ::std::os::raw::c_void,
            args: *mut status_code_domain_vtable_name_args,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "! Information about this domain's payload"]
    pub payload_info: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary1: *const ::std::os::raw::c_void,
            args: *mut status_code_domain_vtable_payload_info_args,
        ),
    >,
    pub failure: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary2: *const ::std::os::raw::c_void,
            code: *const status_code_untyped,
        ) -> bool,
    >,
    pub equivalent: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary3: *const ::std::os::raw::c_void,
            code1: *const status_code_untyped,
            code2: *const status_code_untyped,
        ) -> bool,
    >,
    #[doc = "! Returns the generic code closest to this code, if any."]
    pub generic_code: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary4: *const ::std::os::raw::c_void,
            args: *mut status_code_domain_vtable_generic_code_args,
        ),
    >,
    #[doc = "! Return a reference to a string textually representing a code. Returns an\n! `errno` if it failed."]
    pub message: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary5: *const ::std::os::raw::c_void,
            args: *mut status_code_domain_vtable_message_args,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "! ABI compatibility slot for throwing a code as a C++ exception, do not\n! call this even from C++ (use the C++ implementation instead)."]
    pub reserved_slot_for_cxx_throw_exception: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary6: *const ::std::os::raw::c_void,
            code: *const status_code_untyped,
        ),
    >,
    #[doc = "! For a `status_code<erased<T>>` only, copy from `src` to `dst`. Default\n! implementation uses `memcpy()`. Returns an `errno` if it failed. You\n! should return an error code here if your payload is not trivially\n! copyable or would not fit."]
    pub erased_copy: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary7: *const ::std::os::raw::c_void,
            dst: *mut status_code_untyped,
            src: *const status_code_untyped,
            dstinfo: status_code_domain_payload_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "! For a `status_code<erased<T>>` only, destroy the erased value type.\n! Default implementation does nothing."]
    pub erased_destroy: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary8: *const ::std::os::raw::c_void,
            code: *mut status_code_untyped,
            info: status_code_domain_payload_info_t,
        ),
    >,
}
#[doc = "! \\brief The functions defined by a status code domain, kept ABI compatible\n! with a C++ vtable"]
pub type status_code_domain_vtable = status_code_domain_vtable_s;
#[doc = "! \\brief The functions defined by a status code domain, kept ABI compatible\n! with a C++ vtable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_domain_s {
    #[doc = "! C++ ABI compatible vptr"]
    pub vptr: *const status_code_domain_vtable_s,
    #[doc = "! The unique id used to identify identical category instances."]
    pub id: status_code_domain_unique_id_type,
}
impl Default for status_code_domain_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "! \\brief Parse a uuid input string to yield a status code domain unique id"]
    pub fn status_code_domain_unique_id_from_uuid(
        uuid: *const ::std::os::raw::c_char,
    ) -> status_code_domain_unique_id_type;
}
unsafe extern "C" {
    #[doc = "! \\brief Retrieves the name of the status code domain (implementation). Make\n! sure you call `status_code_domain_string_ref_destroy()` when you are done\n! with the returned string reference."]
    pub fn status_code_domain_name(
        domain: *const status_code_domain_s,
    ) -> status_code_domain_string_ref;
}
unsafe extern "C" {
    #[doc = "! \\brief Retrieves the payload info of the status code domain\n! (implementation)."]
    pub fn status_code_domain_payload_info(
        domain: *const status_code_domain_s,
    ) -> status_code_domain_payload_info_t;
}
unsafe extern "C" {
    #[doc = "! \\brief True if the status code is empty (implementation)"]
    pub fn status_code_is_empty(r: *const status_code_untyped) -> bool;
}
unsafe extern "C" {
    #[doc = "! \\brief True if the status code is a success (implementation)"]
    pub fn status_code_is_success(r: *const status_code_untyped) -> bool;
}
unsafe extern "C" {
    #[doc = "! \\brief True if the status code is a failure (implementation)"]
    pub fn status_code_is_failure(r: *const status_code_untyped) -> bool;
}
unsafe extern "C" {
    #[doc = "! \\brief Retrieves the message of the status code (implementation). Make\n! sure you call `status_code_domain_string_ref_destroy()` when you are done\n! with the returned string reference."]
    pub fn status_code_message(r: *const status_code_untyped) -> status_code_domain_string_ref;
}
unsafe extern "C" {
    #[doc = "! \\brief True if the status codes are strictly semantically equivalent\n! (implementation). `primary`'s domain's equivalence function decides if\n! `secondary` is semantically equivalent to it. Note that for most status\n! codes, if the codes have the same domain, a pure value equality is\n! performed. This operation may not be transitive."]
    pub fn status_code_strictly_equivalent(
        primary: *const status_code_untyped,
        secondary: *const status_code_untyped,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! \\brief Destroys the status code (erased)"]
    pub fn status_code_erased_destroy(r: *mut status_code_untyped);
}
unsafe extern "C" {
    #[doc = "! \\brief Clones the status code (erased), returning an `errno` value\n! if failed."]
    pub fn status_code_erased_clone(
        dest: *mut status_code_untyped,
        src: *const status_code_untyped,
        dstinfo: status_code_domain_payload_info_t,
    ) -> ::std::os::raw::c_int;
}
pub const status_code_errc_status_code_errc_success: status_code_errc = 0;
pub const status_code_errc_status_code_errc_unknown: status_code_errc = -1;
pub const status_code_errc_status_code_errc_address_family_not_supported: status_code_errc = 47;
pub const status_code_errc_status_code_errc_address_in_use: status_code_errc = 48;
pub const status_code_errc_status_code_errc_address_not_available: status_code_errc = 49;
pub const status_code_errc_status_code_errc_already_connected: status_code_errc = 56;
pub const status_code_errc_status_code_errc_argument_list_too_long: status_code_errc = 7;
pub const status_code_errc_status_code_errc_argument_out_of_domain: status_code_errc = 33;
pub const status_code_errc_status_code_errc_bad_address: status_code_errc = 14;
pub const status_code_errc_status_code_errc_bad_file_descriptor: status_code_errc = 9;
pub const status_code_errc_status_code_errc_bad_message: status_code_errc = 94;
pub const status_code_errc_status_code_errc_broken_pipe: status_code_errc = 32;
pub const status_code_errc_status_code_errc_connection_aborted: status_code_errc = 53;
pub const status_code_errc_status_code_errc_connection_already_in_progress: status_code_errc = 37;
pub const status_code_errc_status_code_errc_connection_refused: status_code_errc = 61;
pub const status_code_errc_status_code_errc_connection_reset: status_code_errc = 54;
pub const status_code_errc_status_code_errc_cross_device_link: status_code_errc = 18;
pub const status_code_errc_status_code_errc_destination_address_required: status_code_errc = 39;
pub const status_code_errc_status_code_errc_device_or_resource_busy: status_code_errc = 16;
pub const status_code_errc_status_code_errc_directory_not_empty: status_code_errc = 66;
pub const status_code_errc_status_code_errc_executable_format_error: status_code_errc = 8;
pub const status_code_errc_status_code_errc_file_exists: status_code_errc = 17;
pub const status_code_errc_status_code_errc_file_too_large: status_code_errc = 27;
pub const status_code_errc_status_code_errc_filename_too_long: status_code_errc = 63;
pub const status_code_errc_status_code_errc_function_not_supported: status_code_errc = 78;
pub const status_code_errc_status_code_errc_host_unreachable: status_code_errc = 65;
pub const status_code_errc_status_code_errc_identifier_removed: status_code_errc = 90;
pub const status_code_errc_status_code_errc_illegal_byte_sequence: status_code_errc = 92;
pub const status_code_errc_status_code_errc_inappropriate_io_control_operation: status_code_errc =
    25;
pub const status_code_errc_status_code_errc_interrupted: status_code_errc = 4;
pub const status_code_errc_status_code_errc_invalid_argument: status_code_errc = 22;
pub const status_code_errc_status_code_errc_invalid_seek: status_code_errc = 29;
pub const status_code_errc_status_code_errc_io_error: status_code_errc = 5;
pub const status_code_errc_status_code_errc_is_a_directory: status_code_errc = 21;
pub const status_code_errc_status_code_errc_message_size: status_code_errc = 40;
pub const status_code_errc_status_code_errc_network_down: status_code_errc = 50;
pub const status_code_errc_status_code_errc_network_reset: status_code_errc = 52;
pub const status_code_errc_status_code_errc_network_unreachable: status_code_errc = 51;
pub const status_code_errc_status_code_errc_no_buffer_space: status_code_errc = 55;
pub const status_code_errc_status_code_errc_no_child_process: status_code_errc = 10;
pub const status_code_errc_status_code_errc_no_link: status_code_errc = 97;
pub const status_code_errc_status_code_errc_no_lock_available: status_code_errc = 77;
pub const status_code_errc_status_code_errc_no_message: status_code_errc = 91;
pub const status_code_errc_status_code_errc_no_protocol_option: status_code_errc = 42;
pub const status_code_errc_status_code_errc_no_space_on_device: status_code_errc = 28;
pub const status_code_errc_status_code_errc_no_stream_resources: status_code_errc = 98;
pub const status_code_errc_status_code_errc_no_such_device_or_address: status_code_errc = 6;
pub const status_code_errc_status_code_errc_no_such_device: status_code_errc = 19;
pub const status_code_errc_status_code_errc_no_such_file_or_directory: status_code_errc = 2;
pub const status_code_errc_status_code_errc_no_such_process: status_code_errc = 3;
pub const status_code_errc_status_code_errc_not_a_directory: status_code_errc = 20;
pub const status_code_errc_status_code_errc_not_a_socket: status_code_errc = 38;
pub const status_code_errc_status_code_errc_not_a_stream: status_code_errc = 99;
pub const status_code_errc_status_code_errc_not_connected: status_code_errc = 57;
pub const status_code_errc_status_code_errc_not_enough_memory: status_code_errc = 12;
pub const status_code_errc_status_code_errc_not_supported: status_code_errc = 45;
pub const status_code_errc_status_code_errc_operation_canceled: status_code_errc = 89;
pub const status_code_errc_status_code_errc_operation_in_progress: status_code_errc = 36;
pub const status_code_errc_status_code_errc_operation_not_permitted: status_code_errc = 1;
pub const status_code_errc_status_code_errc_operation_not_supported: status_code_errc = 102;
pub const status_code_errc_status_code_errc_operation_would_block: status_code_errc = 35;
pub const status_code_errc_status_code_errc_owner_dead: status_code_errc = 105;
pub const status_code_errc_status_code_errc_permission_denied: status_code_errc = 13;
pub const status_code_errc_status_code_errc_protocol_error: status_code_errc = 100;
pub const status_code_errc_status_code_errc_protocol_not_supported: status_code_errc = 43;
pub const status_code_errc_status_code_errc_read_only_file_system: status_code_errc = 30;
pub const status_code_errc_status_code_errc_resource_deadlock_would_occur: status_code_errc = 11;
pub const status_code_errc_status_code_errc_resource_unavailable_try_again: status_code_errc = 35;
pub const status_code_errc_status_code_errc_result_out_of_range: status_code_errc = 34;
pub const status_code_errc_status_code_errc_state_not_recoverable: status_code_errc = 104;
pub const status_code_errc_status_code_errc_stream_timeout: status_code_errc = 101;
pub const status_code_errc_status_code_errc_text_file_busy: status_code_errc = 26;
pub const status_code_errc_status_code_errc_timed_out: status_code_errc = 60;
pub const status_code_errc_status_code_errc_too_many_files_open_in_system: status_code_errc = 23;
pub const status_code_errc_status_code_errc_too_many_files_open: status_code_errc = 24;
pub const status_code_errc_status_code_errc_too_many_links: status_code_errc = 31;
pub const status_code_errc_status_code_errc_too_many_symbolic_link_levels: status_code_errc = 62;
pub const status_code_errc_status_code_errc_value_too_large: status_code_errc = 84;
pub const status_code_errc_status_code_errc_wrong_protocol_type: status_code_errc = 41;
#[doc = "! The generic error coding (POSIX)"]
pub type status_code_errc = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = "! \\brief Retrieve the domain for `status_code_generic`"]
    pub fn status_code_generic_domain() -> *const status_code_domain_s;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_generic_s {
    pub base: status_code_untyped,
    pub value: status_code_errc,
}
impl Default for status_code_generic_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static status_code_generic_empty: status_code_generic;
}
unsafe extern "C" {
    #[doc = "! \\brief Make a `status_code_generic`"]
    pub fn status_code_generic_make(val: status_code_errc) -> status_code_generic;
}
#[doc = "! \\brief The arguments for `status_code_domain_vtable.generic_code`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_domain_vtable_generic_code_args {
    pub ret: status_code_generic,
    pub code: *const status_code_untyped,
}
impl Default for status_code_domain_vtable_generic_code_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "! \\brief True if the status codes are semantically equivalent in any way\n! (implementation). Guaranteed transitive. Firstly\n! `status_code_strictly_equivalent()` is run in both directions. If\n! neither succeeds, each domain is asked for the equivalent generic\n! code, and those are compared."]
    pub fn status_code_equivalent(
        primary: *const status_code_untyped,
        secondary: *const status_code_untyped,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! \\brief True if the status code is semantically equivalent in any way\n! to the generic enum value (implementation)."]
    pub fn status_code_equivalent_errc(
        primary: *const status_code_untyped,
        errc: status_code_errc,
    ) -> bool;
}
#[repr(C)]
pub struct status_code_system_s {
    pub base: status_code_untyped,
    pub value: isize,
}
impl Default for status_code_system_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type status_code_system = status_code_system_s;
unsafe extern "C" {
    pub static status_code_system_empty: status_code_system;
}
unsafe extern "C" {
    #[doc = "! \\brief Make a system code from an untyped input status code, this will\n! fail if the input status cannot fit into a system code or if alignment\n! requirements are not met."]
    pub fn status_code_system_make(
        src: *const status_code_untyped,
        dstinfo: status_code_domain_payload_info_t,
    ) -> status_code_system;
}
unsafe extern "C" {
    #[doc = "! \\brief Make a system code from an `enum status_code_errc`"]
    pub fn status_code_system_make_from_errc(errc: status_code_errc) -> status_code_system;
}
pub const result_status_flags_result_status_flag_none: result_status_flags = 0;
pub const result_status_flags_result_status_flag_have_value: result_status_flags = 1;
pub const result_status_flags_result_status_flag_have_error: result_status_flags = 2;
pub const result_status_flags_result_status_flag_have_exception: result_status_flags = 4;
pub const result_status_flags_result_status_flag_have_error_exception: result_status_flags = 6;
pub const result_status_flags_result_status_flag_have_lost_consistency: result_status_flags = 8;
pub const result_status_flags_result_status_flag_have_value_lost_consistency: result_status_flags =
    9;
pub const result_status_flags_result_status_flag_have_error_lost_consistency: result_status_flags =
    10;
pub const result_status_flags_result_status_flag_have_exception_lost_consistency:
    result_status_flags = 12;
pub const result_status_flags_result_status_flag_have_error_exception_lost_consistency:
    result_status_flags = 14;
pub const result_status_flags_result_status_flag_have_error_is_errno: result_status_flags = 16;
pub const result_status_flags_result_status_flag_have_error_error_is_errno: result_status_flags =
    18;
pub const result_status_flags_result_status_flag_have_error_exception_error_is_errno:
    result_status_flags = 22;
pub const result_status_flags_result_status_flag_have_error_lost_consistency_error_is_errno:
    result_status_flags = 26;
pub const result_status_flags_result_status_flag_have_error_exception_lost_consistency_error_is_errno : result_status_flags = 30 ;
pub const result_status_flags_result_status_flag_have_moved_from: result_status_flags = 32;
pub const result_status_flags_result_status_flag_have_value_moved_from: result_status_flags = 33;
pub const result_status_flags_result_status_flag_have_error_moved_from: result_status_flags = 34;
pub const result_status_flags_result_status_flag_have_exception_moved_from: result_status_flags =
    36;
pub const result_status_flags_result_status_flag_have_error_exception_moved_from:
    result_status_flags = 38;
pub const result_status_flags_result_status_flag_have_value_lost_consistency_moved_from:
    result_status_flags = 41;
pub const result_status_flags_result_status_flag_have_error_lost_consistency_moved_from:
    result_status_flags = 42;
pub const result_status_flags_result_status_flag_have_exception_lost_consistency_moved_from:
    result_status_flags = 44;
pub const result_status_flags_result_status_flag_have_error_exception_lost_consistency_moved_from : result_status_flags = 46 ;
pub const result_status_flags_result_status_flag_have_error_is_errno_moved_from:
    result_status_flags = 48;
pub const result_status_flags_result_status_flag_have_error_error_is_errno_moved_from:
    result_status_flags = 50;
pub const result_status_flags_result_status_flag_have_error_exception_error_is_errno_moved_from:
    result_status_flags = 54;
pub const result_status_flags_result_status_flag_have_error_lost_consistency_error_is_errno_moved_from : result_status_flags = 58 ;
pub const result_status_flags_result_status_flag_have_error_exception_lost_consistency_error_is_errno_moved_from : result_status_flags = 62 ;
pub type result_status_flags = ::std::os::raw::c_uint;
#[doc = "! \\brief The flags type within a Result"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union result_flags {
    pub status: result_status_flags,
    pub __bindgen_anon_1: result_flags__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct result_flags__bindgen_ty_1 {
    pub status_bits: u16,
    pub spare_storage_value: u16,
}
impl Default for result_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct result_with_void_s {
    pub _flags_: result_flags,
    pub error: status_code_system,
}
impl Default for result_with_void_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type result_with_void = result_with_void_s;
unsafe extern "C" {
    #[doc = "! \\brief Makes a successful Result with type `void`."]
    pub fn result_void_make_success() -> result_with_void;
}
unsafe extern "C" {
    #[doc = "! \\brief Makes an unsuccessful Result with type `void`."]
    pub fn result_void_make_failure(err: status_code_system) -> result_with_void;
}
unsafe extern "C" {
    #[doc = "! \\brief Retrieve the domain for `status_code_posix`"]
    pub fn status_code_posix_domain() -> *const status_code_domain_s;
}
#[repr(C)]
#[derive(Debug)]
pub struct status_code_posix_s {
    pub base: status_code_untyped,
    pub value: ::std::os::raw::c_int,
}
impl Default for status_code_posix_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type status_code_posix = status_code_posix_s;
unsafe extern "C" {
    #[doc = "! \\brief Make a `status_code_posix`"]
    pub fn status_code_posix_make(val: ::std::os::raw::c_int) -> status_code_posix;
}
