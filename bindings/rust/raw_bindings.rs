/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list<_E> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_E>>,
    pub _M_array: std_initializer_list_iterator<_E>,
    pub _M_len: std_initializer_list_size_type,
}
pub type std_initializer_list_value_type<_E> = _E;
pub type std_initializer_list_reference<_E> = *const _E;
pub type std_initializer_list_const_reference<_E> = *const _E;
pub type std_initializer_list_size_type = usize;
pub type std_initializer_list_iterator<_E> = *const _E;
pub type std_initializer_list_const_iterator<_E> = *const _E;
impl<_E> Default for std_initializer_list<_E> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief Type of a unique id of a domain"]
pub type status_code_domain_unique_id_type = ::std::os::raw::c_ulonglong;
#[doc = "! \\brief Type of a string ref of a domain"]
pub type status_code_domain_string_ref = status_code_domain_string_ref_s;
pub const status_code_domain_string_ref_thunk_op_status_code_domain_string_ref_thunk_op_copy:
    status_code_domain_string_ref_thunk_op = 0;
pub const status_code_domain_string_ref_thunk_op_status_code_domain_string_ref_thunk_op_move:
    status_code_domain_string_ref_thunk_op = 1;
pub const status_code_domain_string_ref_thunk_op_status_code_domain_string_ref_thunk_op_destruct:
    status_code_domain_string_ref_thunk_op = 2;
#[doc = "! \\brief Type of a string ref thunk op"]
pub type status_code_domain_string_ref_thunk_op = ::std::os::raw::c_uint;
#[doc = "! \\brief Type of the arguments to a string ref thunk function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_domain_string_ref_thunk_args_s {
    pub dest: *mut status_code_domain_string_ref,
    pub src: *mut status_code_domain_string_ref,
    pub op: status_code_domain_string_ref_thunk_op,
}
impl Default for status_code_domain_string_ref_thunk_args_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief Type of the arguments to a string ref thunk function"]
pub type status_code_domain_string_ref_thunk_args = status_code_domain_string_ref_thunk_args_s;
#[doc = "! \\brief Type of a string ref thunk function. Returns an `errno` value.\n! Copies can fail. Nothing else can."]
pub type status_code_domain_string_ref_thunk_spec = ::std::option::Option<
    unsafe extern "C" fn(
        args: *const status_code_domain_string_ref_thunk_args,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "! \\brief Type of a string ref of a domain"]
#[repr(C)]
#[derive(Debug)]
pub struct status_code_domain_string_ref_s {
    pub c_str: *const ::std::os::raw::c_char,
    pub end: *const ::std::os::raw::c_char,
    pub state: [*mut ::std::os::raw::c_void; 3usize],
    pub thunk: status_code_domain_string_ref_thunk_spec,
}
unsafe extern "C" {
    #[doc = "! \\brief True if the string ref is empty"]
    #[link_name = "\u{1}_ZNK31status_code_domain_string_ref_s5emptyEv"]
    pub fn status_code_domain_string_ref_s_empty(
        this: *const status_code_domain_string_ref_s,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! \\brief Default construct to all bits zero"]
    #[link_name = "\u{1}_ZN31status_code_domain_string_ref_sC1Ev"]
    pub fn status_code_domain_string_ref_s_status_code_domain_string_ref_s(
        this: *mut status_code_domain_string_ref_s,
    );
}
unsafe extern "C" {
    #[doc = "! \\brief As if aggregate constructor for C compatibility"]
    #[link_name = "\u{1}_ZN31status_code_domain_string_ref_sC1EPKcS1_St16initializer_listIPvEPFiPK42status_code_domain_string_ref_thunk_args_sE"]
    pub fn status_code_domain_string_ref_s_status_code_domain_string_ref_s1(
        this: *mut status_code_domain_string_ref_s,
        c_str: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
        state: std_initializer_list<*mut ::std::os::raw::c_void>,
        thunk: status_code_domain_string_ref_thunk_spec,
    );
}
unsafe extern "C" {
    #[doc = "! \\brief Copies the string ref"]
    #[link_name = "\u{1}_ZN31status_code_domain_string_ref_sC1ERKS_"]
    pub fn status_code_domain_string_ref_s_status_code_domain_string_ref_s2(
        this: *mut status_code_domain_string_ref_s,
        o: *const status_code_domain_string_ref_s,
    );
}
unsafe extern "C" {
    #[doc = "! \\brief Moves the string ref"]
    #[link_name = "\u{1}_ZN31status_code_domain_string_ref_sC1EOS_"]
    pub fn status_code_domain_string_ref_s_status_code_domain_string_ref_s3(
        this: *mut status_code_domain_string_ref_s,
        o: *mut status_code_domain_string_ref_s,
    );
}
unsafe extern "C" {
    #[doc = "! \\brief Destroys the string ref"]
    #[link_name = "\u{1}_ZN31status_code_domain_string_ref_sD1Ev"]
    pub fn status_code_domain_string_ref_s_status_code_domain_string_ref_s_destructor(
        this: *mut status_code_domain_string_ref_s,
    );
}
impl Default for status_code_domain_string_ref_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl status_code_domain_string_ref_s {
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        status_code_domain_string_ref_s_empty(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        status_code_domain_string_ref_s_status_code_domain_string_ref_s(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        c_str: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
        state: std_initializer_list<*mut ::std::os::raw::c_void>,
        thunk: status_code_domain_string_ref_thunk_spec,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        status_code_domain_string_ref_s_status_code_domain_string_ref_s1(
            __bindgen_tmp.as_mut_ptr(),
            c_str,
            end,
            state,
            thunk,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(o: *const status_code_domain_string_ref_s) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        status_code_domain_string_ref_s_status_code_domain_string_ref_s2(
            __bindgen_tmp.as_mut_ptr(),
            o,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(o: *mut status_code_domain_string_ref_s) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        status_code_domain_string_ref_s_status_code_domain_string_ref_s3(
            __bindgen_tmp.as_mut_ptr(),
            o,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        status_code_domain_string_ref_s_status_code_domain_string_ref_s_destructor(self)
    }
}
unsafe extern "C" {
    #[doc = "! \\brief Make an atomic refcounted string ref which tracks living copies\n! using an atomic reference count, freeing the internally stored buffer on\n! final destroy. The input range is copied and does not need to be null\n! terminated. Failure to malloc causes a static string ref to be returned\n! with a string like \"failed to get message from system\"."]
    pub fn status_code_domain_string_ref_atomic_refcounted_from_buffer(
        s: *const ::std::os::raw::c_char,
        len: usize,
    ) -> status_code_domain_string_ref;
}
#[doc = "! \\brief The functions defined by a status code domain, kept ABI compatible\n! with a C++ vtable"]
pub type status_code_domain = status_code_domain_s;
#[doc = "! \\brief Type of a payload info of a domain"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct status_code_domain_payload_info_t {
    #[doc = "!< The payload size in bytes"]
    pub payload_size: usize,
    #[doc = "!< The total status code size in bytes (includes domain pointer and mixins state)"]
    pub total_size: usize,
    #[doc = "!< The total status code alignment in bytes"]
    pub total_alignment: usize,
}
#[doc = "! \\brief Type of an untyped status code"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_untyped {
    pub domain: *const status_code_domain_s,
}
impl Default for status_code_untyped {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The arguments for `status_code_domain_vtable.name`"]
#[repr(C)]
#[derive(Debug)]
pub struct status_code_domain_vtable_name_args {
    pub ret: status_code_domain_string_ref,
    pub domain: *const status_code_domain_s,
}
impl Default for status_code_domain_vtable_name_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The arguments for `status_code_domain_vtable.payload_info`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_domain_vtable_payload_info_args {
    pub ret: status_code_domain_payload_info_t,
    pub domain: *const status_code_domain_s,
}
impl Default for status_code_domain_vtable_payload_info_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The arguments for `status_code_domain_vtable.message`"]
#[repr(C)]
#[derive(Debug)]
pub struct status_code_domain_vtable_message_args {
    pub ret: status_code_domain_string_ref,
    pub code: *const status_code_untyped,
}
impl Default for status_code_domain_vtable_message_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "! \\brief The functions defined by a status code domain, kept ABI compatible\n! with a C++ vtable"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct status_code_domain_vtable_s {
    #[doc = "! Name of this category. Returns an `errno` if it failed."]
    pub name: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary0: *const ::std::os::raw::c_void,
            args: *mut status_code_domain_vtable_name_args,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "! Information about this domain's payload"]
    pub payload_info: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary1: *const ::std::os::raw::c_void,
            args: *mut status_code_domain_vtable_payload_info_args,
        ),
    >,
    #[doc = "! True if code means failure."]
    pub failure: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary2: *const ::std::os::raw::c_void,
            code: *const status_code_untyped,
        ) -> bool,
    >,
    #[doc = "! True if code is (potentially non-transitively) equivalent to another\n! code in another domain."]
    pub equivalent: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary3: *const ::std::os::raw::c_void,
            code1: *const status_code_untyped,
            code2: *const status_code_untyped,
        ) -> bool,
    >,
    #[doc = "! Returns the generic code closest to this code, if any."]
    pub generic_code: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary4: *const ::std::os::raw::c_void,
            args: *mut status_code_domain_vtable_generic_code_args,
        ),
    >,
    #[doc = "! Return a reference to a string textually representing a code. Returns an\n! `errno` if it failed."]
    pub message: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary5: *const ::std::os::raw::c_void,
            args: *mut status_code_domain_vtable_message_args,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "! ABI compatibility slot for throwing a code as a C++ exception, do not\n! call this even from C++ (use the C++ implementation instead)."]
    pub reserved_slot_for_cxx_throw_exception: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary6: *const ::std::os::raw::c_void,
            code: *const status_code_untyped,
        ),
    >,
    #[doc = "! For a `status_code<erased<T>>` only, copy from `src` to `dst`. Default\n! implementation uses `memcpy()`. Returns an `errno` if it failed. You\n! should return an error code here if your payload is not trivially\n! copyable or would not fit."]
    pub erased_copy: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary7: *const ::std::os::raw::c_void,
            dst: *mut status_code_untyped,
            src: *const status_code_untyped,
            dstinfo: status_code_domain_payload_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "! For a `status_code<erased<T>>` only, destroy the erased value type.\n! Default implementation does nothing."]
    pub erased_destroy: ::std::option::Option<
        unsafe extern "C" fn(
            _wg14_result_vtable_api_unique_name_temporary8: *const ::std::os::raw::c_void,
            code: *mut status_code_untyped,
            info: status_code_domain_payload_info_t,
        ),
    >,
}
#[doc = "! \\brief The functions defined by a status code domain, kept ABI compatible\n! with a C++ vtable"]
pub type status_code_domain_vtable = status_code_domain_vtable_s;
#[doc = "! \\brief The functions defined by a status code domain, kept ABI compatible\n! with a C++ vtable"]
#[repr(C)]
#[derive(Debug)]
pub struct status_code_domain_s {
    #[doc = "! C++ ABI compatible vptr"]
    pub vptr: *const status_code_domain_vtable_s,
    #[doc = "! The unique id used to identify identical category instances."]
    pub id: status_code_domain_unique_id_type,
}
unsafe extern "C" {
    #[doc = "! \\brief Retrieves the name of the status code domain"]
    #[link_name = "\u{1}_ZNK20status_code_domain_s4nameEv"]
    pub fn status_code_domain_s_name(
        this: *const status_code_domain_s,
    ) -> status_code_domain_string_ref;
}
unsafe extern "C" {
    #[doc = "! \\brief Retrieves the payload info of the status code domain"]
    #[link_name = "\u{1}_ZNK20status_code_domain_s12payload_infoEv"]
    pub fn status_code_domain_s_payload_info(
        this: *const status_code_domain_s,
    ) -> status_code_domain_payload_info_t;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN20status_code_domain_sC1Ev"]
    pub fn status_code_domain_s_status_code_domain_s(this: *mut status_code_domain_s);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN20status_code_domain_sC1EPK27status_code_domain_vtable_sy"]
    pub fn status_code_domain_s_status_code_domain_s1(
        this: *mut status_code_domain_s,
        vptr: *const status_code_domain_vtable_s,
        id: status_code_domain_unique_id_type,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN20status_code_domain_sC1ERKS_"]
    pub fn status_code_domain_s_status_code_domain_s2(
        this: *mut status_code_domain_s,
        arg1: *const status_code_domain_s,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN20status_code_domain_sC1EOS_"]
    pub fn status_code_domain_s_status_code_domain_s3(
        this: *mut status_code_domain_s,
        arg1: *mut status_code_domain_s,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN20status_code_domain_sD1Ev"]
    pub fn status_code_domain_s_status_code_domain_s_destructor(this: *mut status_code_domain_s);
}
impl Default for status_code_domain_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl status_code_domain_s {
    #[inline]
    pub unsafe fn name(&self) -> status_code_domain_string_ref {
        status_code_domain_s_name(self)
    }
    #[inline]
    pub unsafe fn payload_info(&self) -> status_code_domain_payload_info_t {
        status_code_domain_s_payload_info(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        status_code_domain_s_status_code_domain_s(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        vptr: *const status_code_domain_vtable_s,
        id: status_code_domain_unique_id_type,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        status_code_domain_s_status_code_domain_s1(__bindgen_tmp.as_mut_ptr(), vptr, id);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const status_code_domain_s) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        status_code_domain_s_status_code_domain_s2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *mut status_code_domain_s) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        status_code_domain_s_status_code_domain_s3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        status_code_domain_s_status_code_domain_s_destructor(self)
    }
}
unsafe extern "C" {
    #[doc = "! \\brief Parse a uuid input string to yield a status code domain unique id"]
    pub fn status_code_domain_unique_id_from_uuid(
        uuid: *const ::std::os::raw::c_char,
    ) -> status_code_domain_unique_id_type;
}
#[repr(C)]
#[derive(Debug)]
pub struct wg14_result_status_code_special_member_functions<StorageType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<StorageType>>,
    pub _base: StorageType,
}
#[doc = "! \\brief The type of the status code's payload"]
pub type wg14_result_status_code_special_member_functions_value_type<StorageType> = StorageType;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wg14_result_status_code_special_member_functions__tag_copy_directly {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wg14_result_status_code_special_member_functions__tag_copy_via_domain {
    pub _address: u8,
}
impl<StorageType> Default for wg14_result_status_code_special_member_functions<StorageType> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct wg14_result_wg14_result_special_member_functions<StorageType> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<StorageType>>,
    pub _base: StorageType,
}
impl<StorageType> Default for wg14_result_wg14_result_special_member_functions<StorageType> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct wg14_result_result_storage<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub value: T,
    pub _flags_: result_flags,
    pub error: status_code_system,
}
pub type wg14_result_result_storage_value_type<T> = T;
pub type wg14_result_result_storage_error_type = status_code_system;
impl<T> Default for wg14_result_result_storage<T> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct wg14_result_result<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub _base: wg14_result_wg14_result_special_member_functions<wg14_result_result_storage<T>>,
}
impl<T> Default for wg14_result_result<T> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const status_code_errc_status_code_errc_success: status_code_errc = 0;
pub const status_code_errc_status_code_errc_unknown: status_code_errc = -1;
pub const status_code_errc_status_code_errc_address_family_not_supported: status_code_errc = 97;
pub const status_code_errc_status_code_errc_address_in_use: status_code_errc = 98;
pub const status_code_errc_status_code_errc_address_not_available: status_code_errc = 99;
pub const status_code_errc_status_code_errc_already_connected: status_code_errc = 106;
pub const status_code_errc_status_code_errc_argument_list_too_long: status_code_errc = 7;
pub const status_code_errc_status_code_errc_argument_out_of_domain: status_code_errc = 33;
pub const status_code_errc_status_code_errc_bad_address: status_code_errc = 14;
pub const status_code_errc_status_code_errc_bad_file_descriptor: status_code_errc = 9;
pub const status_code_errc_status_code_errc_bad_message: status_code_errc = 74;
pub const status_code_errc_status_code_errc_broken_pipe: status_code_errc = 32;
pub const status_code_errc_status_code_errc_connection_aborted: status_code_errc = 103;
pub const status_code_errc_status_code_errc_connection_already_in_progress: status_code_errc = 114;
pub const status_code_errc_status_code_errc_connection_refused: status_code_errc = 111;
pub const status_code_errc_status_code_errc_connection_reset: status_code_errc = 104;
pub const status_code_errc_status_code_errc_cross_device_link: status_code_errc = 18;
pub const status_code_errc_status_code_errc_destination_address_required: status_code_errc = 89;
pub const status_code_errc_status_code_errc_device_or_resource_busy: status_code_errc = 16;
pub const status_code_errc_status_code_errc_directory_not_empty: status_code_errc = 39;
pub const status_code_errc_status_code_errc_executable_format_error: status_code_errc = 8;
pub const status_code_errc_status_code_errc_file_exists: status_code_errc = 17;
pub const status_code_errc_status_code_errc_file_too_large: status_code_errc = 27;
pub const status_code_errc_status_code_errc_filename_too_long: status_code_errc = 36;
pub const status_code_errc_status_code_errc_function_not_supported: status_code_errc = 38;
pub const status_code_errc_status_code_errc_host_unreachable: status_code_errc = 113;
pub const status_code_errc_status_code_errc_identifier_removed: status_code_errc = 43;
pub const status_code_errc_status_code_errc_illegal_byte_sequence: status_code_errc = 84;
pub const status_code_errc_status_code_errc_inappropriate_io_control_operation: status_code_errc =
    25;
pub const status_code_errc_status_code_errc_interrupted: status_code_errc = 4;
pub const status_code_errc_status_code_errc_invalid_argument: status_code_errc = 22;
pub const status_code_errc_status_code_errc_invalid_seek: status_code_errc = 29;
pub const status_code_errc_status_code_errc_io_error: status_code_errc = 5;
pub const status_code_errc_status_code_errc_is_a_directory: status_code_errc = 21;
pub const status_code_errc_status_code_errc_message_size: status_code_errc = 90;
pub const status_code_errc_status_code_errc_network_down: status_code_errc = 100;
pub const status_code_errc_status_code_errc_network_reset: status_code_errc = 102;
pub const status_code_errc_status_code_errc_network_unreachable: status_code_errc = 101;
pub const status_code_errc_status_code_errc_no_buffer_space: status_code_errc = 105;
pub const status_code_errc_status_code_errc_no_child_process: status_code_errc = 10;
pub const status_code_errc_status_code_errc_no_link: status_code_errc = 67;
pub const status_code_errc_status_code_errc_no_lock_available: status_code_errc = 37;
pub const status_code_errc_status_code_errc_no_message: status_code_errc = 42;
pub const status_code_errc_status_code_errc_no_protocol_option: status_code_errc = 92;
pub const status_code_errc_status_code_errc_no_space_on_device: status_code_errc = 28;
pub const status_code_errc_status_code_errc_no_stream_resources: status_code_errc = 63;
pub const status_code_errc_status_code_errc_no_such_device_or_address: status_code_errc = 6;
pub const status_code_errc_status_code_errc_no_such_device: status_code_errc = 19;
pub const status_code_errc_status_code_errc_no_such_file_or_directory: status_code_errc = 2;
pub const status_code_errc_status_code_errc_no_such_process: status_code_errc = 3;
pub const status_code_errc_status_code_errc_not_a_directory: status_code_errc = 20;
pub const status_code_errc_status_code_errc_not_a_socket: status_code_errc = 88;
pub const status_code_errc_status_code_errc_not_a_stream: status_code_errc = 60;
pub const status_code_errc_status_code_errc_not_connected: status_code_errc = 107;
pub const status_code_errc_status_code_errc_not_enough_memory: status_code_errc = 12;
pub const status_code_errc_status_code_errc_not_supported: status_code_errc = 95;
pub const status_code_errc_status_code_errc_operation_canceled: status_code_errc = 125;
pub const status_code_errc_status_code_errc_operation_in_progress: status_code_errc = 115;
pub const status_code_errc_status_code_errc_operation_not_permitted: status_code_errc = 1;
pub const status_code_errc_status_code_errc_operation_not_supported: status_code_errc = 95;
pub const status_code_errc_status_code_errc_operation_would_block: status_code_errc = 11;
pub const status_code_errc_status_code_errc_owner_dead: status_code_errc = 130;
pub const status_code_errc_status_code_errc_permission_denied: status_code_errc = 13;
pub const status_code_errc_status_code_errc_protocol_error: status_code_errc = 71;
pub const status_code_errc_status_code_errc_protocol_not_supported: status_code_errc = 93;
pub const status_code_errc_status_code_errc_read_only_file_system: status_code_errc = 30;
pub const status_code_errc_status_code_errc_resource_deadlock_would_occur: status_code_errc = 35;
pub const status_code_errc_status_code_errc_resource_unavailable_try_again: status_code_errc = 11;
pub const status_code_errc_status_code_errc_result_out_of_range: status_code_errc = 34;
pub const status_code_errc_status_code_errc_state_not_recoverable: status_code_errc = 131;
pub const status_code_errc_status_code_errc_stream_timeout: status_code_errc = 62;
pub const status_code_errc_status_code_errc_text_file_busy: status_code_errc = 26;
pub const status_code_errc_status_code_errc_timed_out: status_code_errc = 110;
pub const status_code_errc_status_code_errc_too_many_files_open_in_system: status_code_errc = 23;
pub const status_code_errc_status_code_errc_too_many_files_open: status_code_errc = 24;
pub const status_code_errc_status_code_errc_too_many_links: status_code_errc = 31;
pub const status_code_errc_status_code_errc_too_many_symbolic_link_levels: status_code_errc = 40;
pub const status_code_errc_status_code_errc_value_too_large: status_code_errc = 75;
pub const status_code_errc_status_code_errc_wrong_protocol_type: status_code_errc = 91;
#[doc = "! The generic error coding (POSIX)"]
pub type status_code_errc = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = "! \\brief Retrieve the domain for `status_code_generic`"]
    pub fn status_code_generic_domain() -> *const status_code_domain_s;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_generic_s {
    pub base: status_code_untyped,
    pub value: status_code_errc,
}
impl Default for status_code_generic_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct status_code_generic {
    pub _base: wg14_result_status_code_special_member_functions<status_code_generic_s>,
}
impl Default for status_code_generic {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZL25status_code_generic_empty"]
    pub static status_code_generic_empty: status_code_generic;
}
#[doc = "! \\brief The arguments for `status_code_domain_vtable.generic_code`"]
#[repr(C)]
#[derive(Debug)]
pub struct status_code_domain_vtable_generic_code_args {
    pub ret: status_code_generic,
    pub code: *const status_code_untyped,
}
impl Default for status_code_domain_vtable_generic_code_args {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status_code_system_s {
    pub base: status_code_untyped,
    pub value: isize,
}
impl Default for status_code_system_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct status_code_system {
    pub _base: wg14_result_status_code_special_member_functions<status_code_system_s>,
}
impl Default for status_code_system {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZL24status_code_system_empty"]
    pub static status_code_system_empty: status_code_system;
}
pub const result_status_flags_result_status_flag_none: result_status_flags = 0;
pub const result_status_flags_result_status_flag_have_value: result_status_flags = 1;
pub const result_status_flags_result_status_flag_have_error: result_status_flags = 2;
pub const result_status_flags_result_status_flag_have_exception: result_status_flags = 4;
pub const result_status_flags_result_status_flag_have_error_exception: result_status_flags = 6;
pub const result_status_flags_result_status_flag_have_lost_consistency: result_status_flags = 8;
pub const result_status_flags_result_status_flag_have_value_lost_consistency: result_status_flags =
    9;
pub const result_status_flags_result_status_flag_have_error_lost_consistency: result_status_flags =
    10;
pub const result_status_flags_result_status_flag_have_exception_lost_consistency:
    result_status_flags = 12;
pub const result_status_flags_result_status_flag_have_error_exception_lost_consistency:
    result_status_flags = 14;
pub const result_status_flags_result_status_flag_have_error_is_errno: result_status_flags = 16;
pub const result_status_flags_result_status_flag_have_error_error_is_errno: result_status_flags =
    18;
pub const result_status_flags_result_status_flag_have_error_exception_error_is_errno:
    result_status_flags = 22;
pub const result_status_flags_result_status_flag_have_error_lost_consistency_error_is_errno:
    result_status_flags = 26;
pub const result_status_flags_result_status_flag_have_error_exception_lost_consistency_error_is_errno : result_status_flags = 30 ;
pub const result_status_flags_result_status_flag_have_moved_from: result_status_flags = 32;
pub const result_status_flags_result_status_flag_have_value_moved_from: result_status_flags = 33;
pub const result_status_flags_result_status_flag_have_error_moved_from: result_status_flags = 34;
pub const result_status_flags_result_status_flag_have_exception_moved_from: result_status_flags =
    36;
pub const result_status_flags_result_status_flag_have_error_exception_moved_from:
    result_status_flags = 38;
pub const result_status_flags_result_status_flag_have_value_lost_consistency_moved_from:
    result_status_flags = 41;
pub const result_status_flags_result_status_flag_have_error_lost_consistency_moved_from:
    result_status_flags = 42;
pub const result_status_flags_result_status_flag_have_exception_lost_consistency_moved_from:
    result_status_flags = 44;
pub const result_status_flags_result_status_flag_have_error_exception_lost_consistency_moved_from : result_status_flags = 46 ;
pub const result_status_flags_result_status_flag_have_error_is_errno_moved_from:
    result_status_flags = 48;
pub const result_status_flags_result_status_flag_have_error_error_is_errno_moved_from:
    result_status_flags = 50;
pub const result_status_flags_result_status_flag_have_error_exception_error_is_errno_moved_from:
    result_status_flags = 54;
pub const result_status_flags_result_status_flag_have_error_lost_consistency_error_is_errno_moved_from : result_status_flags = 58 ;
pub const result_status_flags_result_status_flag_have_error_exception_lost_consistency_error_is_errno_moved_from : result_status_flags = 62 ;
pub type result_status_flags = ::std::os::raw::c_uint;
#[doc = "! \\brief The flags type within a Result"]
#[repr(C)]
pub union result_flags {
    pub status: result_status_flags,
    pub __bindgen_anon_1: result_flags__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct result_flags__bindgen_ty_1 {
    pub status_bits: u16,
    pub spare_storage_value: u16,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK12result_flags10have_valueEv"]
    pub fn result_flags_have_value(this: *const result_flags) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK12result_flags10have_errorEv"]
    pub fn result_flags_have_error(this: *const result_flags) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK12result_flags14have_exceptionEv"]
    pub fn result_flags_have_exception(this: *const result_flags) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZNK12result_flags21have_lost_consistencyEv"]
    pub fn result_flags_have_lost_consistency(this: *const result_flags) -> bool;
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN12result_flagsC1Ev"]
    pub fn result_flags_result_flags(this: *mut result_flags);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN12result_flagsC1E19result_status_flags"]
    pub fn result_flags_result_flags1(this: *mut result_flags, v: result_status_flags);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN12result_flagsC1ERKS_"]
    pub fn result_flags_result_flags2(this: *mut result_flags, arg1: *const result_flags);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN12result_flagsC1EOS_"]
    pub fn result_flags_result_flags3(this: *mut result_flags, arg1: *mut result_flags);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN12result_flagsD1Ev"]
    pub fn result_flags_result_flags_destructor(this: *mut result_flags);
}
impl Default for result_flags {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl result_flags {
    #[inline]
    pub unsafe fn have_value(&self) -> bool {
        result_flags_have_value(self)
    }
    #[inline]
    pub unsafe fn have_error(&self) -> bool {
        result_flags_have_error(self)
    }
    #[inline]
    pub unsafe fn have_exception(&self) -> bool {
        result_flags_have_exception(self)
    }
    #[inline]
    pub unsafe fn have_lost_consistency(&self) -> bool {
        result_flags_have_lost_consistency(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        result_flags_result_flags(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(v: result_status_flags) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        result_flags_result_flags1(__bindgen_tmp.as_mut_ptr(), v);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const result_flags) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        result_flags_result_flags2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *mut result_flags) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        result_flags_result_flags3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        result_flags_result_flags_destructor(self)
    }
}
#[repr(C)]
pub struct result_with_void_s {
    pub _flags_: result_flags,
    pub error: status_code_system,
}
impl Default for result_with_void_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct result_with_void {
    pub _base: wg14_result_wg14_result_special_member_functions<result_with_void_s>,
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN16result_with_voidC1Ev"]
    pub fn result_with_void_result_with_void(this: *mut result_with_void);
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN16result_with_voidC1ERKS_"]
    pub fn result_with_void_result_with_void1(
        this: *mut result_with_void,
        arg1: *const result_with_void,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN16result_with_voidC1EOS_"]
    pub fn result_with_void_result_with_void2(
        this: *mut result_with_void,
        arg1: *mut result_with_void,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}_ZN16result_with_voidD1Ev"]
    pub fn result_with_void_result_with_void_destructor(this: *mut result_with_void);
}
impl Default for result_with_void {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl result_with_void {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        result_with_void_result_with_void(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const result_with_void) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        result_with_void_result_with_void1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut result_with_void) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        result_with_void_result_with_void2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        result_with_void_result_with_void_destructor(self)
    }
}
